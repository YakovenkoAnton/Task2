1. Дайте определение понятию “исключение”.
Исключение – это проблема(ошибка) возникающая во время выполнения программы. Исключения могут возникать во многих случаях, например: пользователь ввел некорректные данные, файл, к которому обращается программа, не найден, сетевое соединение с сервером было утеряно во время передачи данных, попытка индексации вне границ массива, вызов метода на нулевой ссылке или деление на нуль.
Все исключения в Java являются объектами. Поэтому они могут порождаться не только автоматически при возникновении исключительной ситуации, но и создаваться самим разработчиком.
При возникновении исключения создается объект, описывающий это исключение. Затем текущий ход выполнения приложения останавливается, и включается механизм обработки исключений. При этом ссылка на объект-исключение передается обработчику исключений, который пытается решить возникшую проблему и продолжить выполнение программы.

2. Какова иерархия исключений.
Исключения делятся на несколько классов, но все они имеют общего предка — класс Throwable. Его потомками являются подклассы Exception и Error.
Исключения (Exceptions) являются результатом проблем в программе, которые в принципе решаемые и предсказуемые. Например, произошло деление на ноль в целых числах.
Ошибки (Errors) представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует пытаться обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память, доступная виртуальной машине. Программа дополнительную память всё равно не сможет обеспечить для JVM.
В Java все исключения делятся на два типа: контролируемые исключения (checked) и неконтролируемые исключения (unchecked), к которым относятся ошибки (Errors) и исключения времени выполнения (RuntimeExceptions, потомок класса Exception).
Контролируемые исключения представляют собой ошибки, которые можно и нужно обрабатывать в программе, к этому типу относятся все потомки класса Exception (но не RuntimeException).

3. Можно/нужно ли обрабатывать ошибки jvm?
Обрабатывать можно, но разработчику не предоставлены инструменты для обработки ошибок системы и виртуальной машины.

4. Какие существуют способы обработки исключений?
В Java есть пять ключевых слов для работы с исключениями:
try – данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.
catch – ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений.
finally – ключевое слово для отметки начала блока кода, которой является дополнительным. Этот блок помещается после последнего блока ‘catch’. Управление обычно передаётся в блок ‘finally’ в любом случае.
throw – служит для генерации исключений.
throws – ключевое слово, которое прописывается в сигнатуре метода, и обозначающее что метод потенциально может выбросить исключение с указанным типом.
Общий вид конструкции для “поимки” исключительной ситуации выглядит следующим образом:

try{ //здесь код, который потенциально может привести к ошибке
}
catch(SomeException e ){ //в скобках указывается класс конкретной ожидаемой ошибки  
//здесь описываются действия, направленные на обработку исключений
}
finally{ //выполняется в любом случае ( блок finally  не обязателен)
}
5. О чем говорит ключевое слово throws?
throws – ключевое слово, которое прописывается в сигнатуре метода, и обозначающее, что метод потенциально может выбросить исключение с указанным типом.
6. В чем особенность блока finally? Всегда ли он исполняется?
   Когда исключение передано, выполнение метода направляется по нелинейному пути. Это может стать источником проблем. Например, при входе метод открывает файл и закрывает при выходе. Чтобы закрытие файла не было пропущено из-за обработки исключения, был предложен механизм finally.
   Ключевое слово finally создаёт блок кода, который будет выполнен после завершения блока try/catch, но перед кодом, следующим за ним. Блок будет выполнен, независимо от того, передано исключение или нет. Оператор finally не обязателен, однако каждый оператор try требует наличия либо catch, либо finally. Код в блоке finally будет выполнен всегда.
   Если необходимо гарантировано выполнить определенный участок кода, то используется finally. Связка try/finally позволяет обеспечить выполнение блока кода независимо от того, какие исключения были возбуждены и перехвачены, даже в тех случаях, когда в методе нет соответствующего возбужденному исключению раздела catch. Блок filally выполняется не всегда см. п.8.

7. Может ли не быть ни одного блока catch при отлавливании исключений?
      Такая запись допустима, если имеется связка try{} finally {}. Но смысла в такой записи не так много, всё же лучше иметь блок catch в котором будет обрабатываться необходимое исключение.

8. Могли бы вы придумать ситуацию, когда блок finally не будет выполнен?
Код блока finally не будет исполнен, если в код программы включен предшествующий блоку finally системный выход.  Так же это возможно когда умирает поток который вызывает исключение. Остановка работы JVM.
9.Может ли один блок catch отлавливать несколько исключений (с одной и разных веток наследований)?
       В Java 7 стала доступна новая конструкция, с помощью которой можно перехватывать несколько исключений одним блоком catch:
       try {  
       ...
       } catch( IOException | SQLException ex ) {  
       logger.log(ex);
       throw ex;
       }

11. Что вы знаете об обрабатываемых и не обрабатываемых (checked/unchecked) исключениях?
    в java есть два типа исключений: checked и unchecked.
12. Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода. Unchecked могут не обрабатываться и не быть описанными.
13. Unchecked исключения в Java - наследованные от RuntimeException, checked - от Exception (не включая unchecked).
    Пример unchecked исключения - NullPointerException, checked исключения - IOException


11. В чем особенность RuntimeException?




public class RuntimeException extends Exception – базовый класс для ошибок во время выполнения. Относится к необрабатываемым исключениям (uncatched\unchecked). Как сказано в описании класса – это суперкласс, исключения которого могут быть выброшены во время нормальной работы JVM.
12. Как написать собственное (“пользовательское”) исключение? Какими мотивами вы будете руководствоваться при выборе типа исключения: checked/unchecked?
    Необходимо унаследоваться от базового класса требуемого типа исключений (например от Exception или RuntimeException).

public class ExcClass extends Exception {

    private String someString;
 
    public ExcClass (String string) {
        this.someString = string;
        System.out.println("Exception ExcClass");
    }
 
    public void myOwnExceptionMsg() {
        System.err.println("This is exception message for string: " + someString);
    }
}

public class TestExc {

    public static void main(String[] args) {
        try {
            String s = "SomeString";
            throw new ExcClass(s);
        } catch (ExcClass ex) {
            ex.myOwnExceptionMsg();
        }
    }
}

Exception ExcClass
This is exception message for string: SomeString
Руководствоваться нужно определением типа исключения. В зависимости от того, что вы хотите обрабатывать или видеть нужно и наследоваться от нужного класса.



13. Какой оператор позволяет принудительно выбросить исключение?
    throw new Exception();

14. Есть ли дополнительные условия к методу, который потенциально может выбросить исключение?
    Если это проверяемое исключение, то оно должно быть задекларировано в сигнатуре метода.
    public void someMethod() throws Exception {
    }

15. Может ли метод main выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?
    Может и оно будет передано в виртуальную машину Java (JVM).

16. Если оператор return содержится и в блоке catch и в finally, какой из них “главнее”?

Вернется из блока finally.
public static void main(String[] args) {
String what =  method();
System.out.println(what);
}

    public static String method() {
        try {
            return "SomeString";
        } catch(Exception ex) {
            return "Catch message";
        } finally {
            return "Finally message";
        }
    }


Finally message



17. Что вы знаете о OutOfMemoryError?
    OutOfMemoryError выбрасывается, когда виртуальная машина Java не может выделить (разместить) объект из-за нехватки памяти, а сборщик мусора не может высвободить ещё.
    Область памяти, занимаемая java процессом, состоит из нескольких частей. Тип OutOfMemoryError зависит от того, в какой из них не хватило места.

1. java.lang.OutOfMemoryError: Java heap space
   Не хватает места в куче, а именно, в области памяти в которую помещаются объекты, создаваемые програмно в вашем приложении. Размер задается параметрами -Xms и -Xmx. Если вы пытаетесь создать объект, а места в куче не осталось, то получаете эту ошибку. Обычно проблема кроется в утечке памяти, коих бывает великое множество.
2. java.lang.OutOfMemoryError: PermGen space
   Данная ошибка возникает при нехватке места в Permanent области, размер которой задается параметрами -XX:PermSize и -XX:MaxPermSize.
3. java.lang.OutOfMemoryError: GC overhead limit exceeded
   Данная ошибка может возникнуть как при переполнении первой, так и второй областей. Связана она с тем, что памяти осталось мало и GC постоянно работает, пытаясь высвободить немного места. Данную ошибку можно отключить с помощью параметра -XX:-UseGCOverheadLimit, но, конечно же, её надо не отключать, а либо решать проблему утечки памяти, либо выделять больше объема, либо менять настройки GC.
4. java.lang.OutOfMemoryError: unable to create new native thread
   Выбрасывается, когда нет возможности создать еще потоки.
   http://habrahabr.ru/post/117274/

18. Что вы знаете о SQLException? К какому типу checked или unchecked оно относится, почему?
    SQLException предоставляет информацию об ошибках доступа к базе данных или других ошибках связанных с работой с базами данных.
    SQLException относится к checked исключениям, а значит проверяется на этапе компиляции.
    Споры об этом типе исключения идут о том, что разработчику приходится постоянно обрабатывать это исключение в коде, хотя большая часть ошибок возникает во время выполнения программы, т.е., по мнению многих, лучше бы отнести его к unchecked runtime исключениям.


19. Что такое Error? В каком случае используется Error. Приведите пример Error’а.
    Ошибки (Errors) представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует пытаться обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память, доступная виртуальной машине.
    Например – OutOfMemoryError.

20. Какая конструкция используется в Java для обработки исключений?
    Можно использовать try-catch-finally и c 7й Java try-with-resources.

21. Предположим, есть блок try-finally. В блоке try возникло исключение и выполнение переместилось в блок finally. В блоке finally тоже возникло исключение. Какое из двух исключений “выпадет” из блока try-finally? Что случится со вторым исключением?
    будет обработано в finally блоке. Если было выброшено два исключения – одно в try, второе в finally, то исключение в finally “проглотит” исключение выше. Если до блока finally исключение было обработано, то мы можем получить информацию об исключении в блоке try и тем самым не потерять исключение, которое впоследствии может быть перезаписано в finally другим исключением.

22. Предположим, есть метод, который может выбросить IOException и FileNotFoundException в какой последовательности должны идти блоки catch? Сколько блоков catch будет выполнено?
    Общее правило – обрабатывать исключения нужно от “младшего” к старшему. Т.е. нельзя поставить в первый блок catch(Exception e) {}, иначе все дальнейшие блоки catch() уже ничего не смогут обработать, т.к. любое исключение будет попадать под ExceptionName extends Exception.
    Таким образом сначала нужно обработать public class FileNotFoundException extends IOException, а затем уже IOException.


	    public static void ioExcAndFileNotFoundEx() {
        try {
            //TODO: some code
            String x = "abc";
            if (x.equals("abc")) {
                throw new IOException();
            } else {
                throw new FileNotFoundException();
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.getMessage();
       }
    }
